// @Author Jokūbas Bučelis 1 lab.
/* autogenerated by Processing revision 1281 on 2022-03-04 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Jumper extends PApplet {

// Jokubas Bucelis
PImage sprite,wallpaper,tileset;
PImage[] tiles,idleSprites,runSprites;

int IDs[];

boolean left, right, up, down, space;

WinPlatform goal;
Hero h;
Platform [] platforms;
FrameObject gameWorld,camera;
BackgroundObject backImage;
JSONHandler MapJSON;
tileEditor editor;



 public void setup() {
  /* size commented out by preprocessor */;
  textSize(64);
  frameRate(60);
  left = false;
  right = false;
  up = false;
  down = false;
  space = false;
  
  editor = new tileEditor();
  
  goal = new WinPlatform();
  goal.GOAL = new Platform(0,-2600,960,16,"safe",-1);
  
  IDs = new int[60*180];

  MapJSON = new JSONHandler();
  MapJSON.JsonRead(IDs);
  
  tileset = loadImage("Tileset.png");
  tiles = new PImage[6*8];
  for(int y = 0;y<6;y++){
   for(int x = 0;x<8;x++){
     tiles[y*8+x] = tileset.get(x*16,y*16,16,16);
   }
  }
  
  sprite = loadImage("Knight.png");
  wallpaper = loadImage("sky.png");
  backImage = new BackgroundObject(0,0, 600, 1000,wallpaper);
  gameWorld = new FrameObject(0,0,960,4000);
  camera = new FrameObject(0,0,width,height);
   
  idleSprites = new PImage[8];
  for(int i = 0;i<8;i++){
   idleSprites[i]=sprite.get(64*i,0,64,64); 
  }
  runSprites = new PImage[8];
  for(int i = 0;i<8;i++){
   runSprites[i]=sprite.get(64*i,64,64,64); 
  }
  
  h = new Hero();
  //Loads all tiles
  platforms = new Platform[60*180];
  for(int y = 0; y < 180;y++){
    for(int x = 0; x < 60;x++){
      platforms[y*60+x] = new Platform (x*16,y*16-2580,16,16,"safe",IDs[y*60+x]);
      println(y*60+x);
    }
  }
}

 public void draw() {
  background(255);
  h.update();
  
  //Keeps camera on player;
  camera.x = floor(h.x + (h.halfWidth) - (camera.w / 2));
  camera.y = floor(h.y + (h.halfHeight) - (camera.h / 2));
  
  //Colission
  for (int i = 0; i < 60*180; ++i) {
    h.collisionSide = rectangleCollisions(h, platforms[i]);
    h.checkPlatforms();
  }
  //WinCondition
  if(rectangleCollisions(h, goal.GOAL)!= "none"){
    MapJSON.mapnumber++;
    goal.nextStage();
    
  }
  
   //Keep the camera inside the gameWorld boundaries
   //Left limit
  if (camera.x < gameWorld.x) {
    camera.x = gameWorld.x;
  }
  //Top limist
  if (camera.y < gameWorld.y - gameWorld.h) {
    camera.y = gameWorld.y;
  }
  //Right Limit
  if (camera.x + camera.w > gameWorld.x + gameWorld.w) {
    camera.x = gameWorld.x + gameWorld.w - camera.w;
  }
  //Bottom limit
  if (camera.y + camera.h > gameWorld.h) {
    camera.y = gameWorld.h - camera.h;
  }
  backImage.display();
  
  pushMatrix();
  translate(-camera.x, -camera.y);
  h.display();
  for (int i = 0; i < 60*180; ++i) {
    platforms[i].display();
  }
  goal.GOAL.display();
  //TileEdtior
  if(key=='z'){
     editor.draw();
     editor.cutImage();
     editor.putTile();
     
   }
    
   popMatrix();
   
   
 // displayPositionData();
}
 public void displayPositionData() {
  fill(0);
  String s = "\nvx: "+h.vx+"  vy: "+h.vy + 
    "\ncollisionSide: "+h.collisionSide +
    "\nisOnGround: "+h.isOnGround +
    "\ny: "+h.y+" x: "+h.x+ "acc: "+h.accelerationX;
  text(s, 50, 50);
}
 public String rectangleCollisions(Hero r1, Platform r2) {
  ////r1 is the player
  ////r2 is the platform rectangle
  ////function returns the String collisionSide

  //To ignore top collision
  //if (r1.vy < 0) { return "none"; }

  float dx = (r1.x+r1.w/2) - (r2.x+r2.w/2);
  float dy = (r1.y+r1.h/2) - (r2.y+r2.h/2);

  float combinedHalfWidths = r1.halfWidth + r2.halfWidth;
  float combinedHalfHeights = r1.halfHeight + r2.halfHeight;
  if (r2.id==0){return "none";}
  

  if (abs(dx) < combinedHalfWidths) {
    ////collision has happened on the x axis
    ////now check on the y axis
    if (abs(dy) < combinedHalfHeights) {
      ////collision detected
      //determine the overlap on each axis
      float overlapX = combinedHalfWidths - abs(dx);
      float overlapY = combinedHalfHeights - abs(dy);
      ////the collision is on the axis with the
      ////SMALLEST overlap
      if (overlapX >= overlapY) {
        if (dy > 0) {
          ////move the rectangle back to eliminate overlap
          ////before calling its display to prevent
          ////drawing object inside each other
          r1.y += (overlapY+0.1f); //0.1to prevent clipping
          return "top";
        } else {
          r1.y -= (overlapY+0.1f);   //0.1 to prevent clipping
          return "bottom";
        }
      } else {
        if (dx > 0) {
          r1.x += overlapX;
          return "left";
        } else {
          r1.x -= overlapX;
          return "right";
        }
      }
    } else {
      //collision failed on the y axis
      return "none";
    }
  } else {
    //collision failed on the x axis
    return "none";
  }
}

 public void keyPressed() {
  switch (keyCode) {
  case 37://left
    left = true;
    break;
  case 39://right
    right = true;
    break;
  case 38://up
    up = true;
    break;
  case 40://down
    down = true;
    break;
  }
}
 public void keyReleased() {
  switch (keyCode) {
  case 37://left
    left = false;
    break;
  case 39://right
    right = false;
    break;
  case 38://up
    up = false;
    break;
  case 40://down
    down = false;
    break;
  }
}
class BackgroundObject{
  float w,h,x,y;
  PImage img;
  
  BackgroundObject(float _x, float _y, float _w, float _h, PImage _img){
    w = _w;
    h = _h;
    x = _x;
    y = _y;
    img = _img;
  }
  
   public void display(){
    image(img,x,y);
  }
}
class FrameObject{
  float x,y,w,h;
  
  FrameObject(float _x, float _y, float _w, float _h){
    w = _w;
    h = _h;
    x = _x;
    y = _y;
  }
}
class Hero {

  float w, h, x, y, vx, vy,
    accelerationX, accelerationY,
    speedLimit;

  float friction, bounce, gravity;

  boolean isOnGround;
  float jumpForce;

  float halfWidth, halfHeight;
  String collisionSide;
  
  boolean Left;
  int counter;

  Hero() {
    w = 48;
    h = 48;
    x = 400;
    y = 150;
    vx = 0;
    vy = 0;
    counter=0;
    accelerationX = 0;
    accelerationY = 0;
    speedLimit = 10;
    isOnGround = false;
    jumpForce = -10;
    Left=false;

    friction = 0.96f;
    bounce = -0.7f;
    gravity = 0.3f;

    halfWidth = w/2;
    halfHeight = h/2;
  
    collisionSide = "";
  }

   public void update() {
    
    if(vx>0){
      Left=false;
    }
    if(vx<0){
      Left=true;
    }
    
    if (left && !right) {
      accelerationY = -0.0001f;
      accelerationX = -0.2f;
      friction = 1;
      Left=true;
    }
    if (right && !left) {
      accelerationX = 0.2f;
      friction = 1;
      Left=false;
    }
    if (!left&&!right) {
      accelerationX = 0;
    }

    if (up && !down && isOnGround) {
      vy = jumpForce;
      isOnGround = false;
      friction = 1;
      jumpForce=-10;
    }
    if (down && !up) {
      accelerationY = 0.2f;
      jumpForce=-20;
    }
   // if (!up&&!down) {
   // }
    if (!up && !down && !left && !right){
     friction = 0.96f; 
    }

    vx += accelerationX;
    vy += accelerationY;
    
    vx *= friction;
    
    vy += gravity;

    //Speed limit
    if (vx > speedLimit) {
      vx = speedLimit;
    }
    if (vx < -speedLimit) {
      vx = -speedLimit;
    }
    if (vy > speedLimit) {
      vy = speedLimit;
    }
  //  if (vy < -speedLimit) {
  //    vy = -speedLimit;
  //  }

    if (abs(vx) < 0.1f) {
     vx = 0; 
    }
    
    //Updates hero position within limits
    x = Math.max(0,Math.min(x+vx,gameWorld.w-w));
    y = Math.min(gameWorld.h,min(y+vy,600));
    
    checkBoundaries(); 
  }
   public void checkBoundaries(){
    //Left
    if (x <= 0){
      vx *= bounce;
    }
    //Right
    if (x + w >= gameWorld.w){
      vx *= bounce;
    }
  }
   public void checkPlatforms() {
    if (collisionSide == "bottom" && vy >= 0) {
      if (vy < 5) {
        isOnGround = true;
        vy = 0;
      } else {
        vy *= bounce/2;
      }
    } else if (collisionSide == "top" && vy <= 0) {
      vy = 0;
    } else if (collisionSide == "right" && vx >= 0) {
      vx = 0;
    } else if (collisionSide == "left" && vx <= 0) {
      vx = 0;
    }
  //  if (collisionSide != "bottom" && vy > 0) {
  //    isOnGround = false;
  // }
  }

   public void display() {
    
   // fill(0, 255, 0, 128);
    //rect(x, y, w, h);
    if(vx==0){
      if(!Left){
        image(idleSprites[counter],x-w,y-w-10,w*3,h*3);
      }
      else{
        //Prints mirrored sprite
        pushMatrix();
        scale(-1,1);
        image(idleSprites[counter],-(x+w)-w,y-w-10,w*3,h*3);
        popMatrix();
      }
    }
    if(vx>0){
      image(runSprites[counter],x-w,y-w-10,w*3,h*3);
    }
    if(vx<0){
      //Prints mirrored sprite
      pushMatrix();
      scale(-1,1);
      image(runSprites[counter],-(x+w)-w,y-w-10  ,w*3,h*3);
      popMatrix();
    }
    //Animation speed
    if (frameCount % 10 == 0){
      counter++;
    }
    //Animation frames
    if (counter>7){
      counter=0;
    }
  }
}
class JSONHandler{
  JSONObject json;
  JSONArray layer;
  JSONObject data;
  JSONArray map;
  int mapnumber = 1;
  
   public void JsonRead(int IDs[]){
    
    if (mapnumber==4){mapnumber = 1;};
    
      json = loadJSONObject("level"+mapnumber+".json");
      layer = json.getJSONArray("layers");
      data = layer.getJSONObject(0);
      map = data.getJSONArray("data");
      
      //Reads tile IDs from json
      for(int i = 0;i < 60*180;i++){
        IDs[i]= PApplet.parseInt(map.getInt(i));
      }
      
  }
   public void JsonPrint(){
    
    //Puts tile IDs in json
    for(int i = 0;i < 60*180;i++){
      map.setInt(i,IDs[i]);
    }
    saveJSONObject(json,"level"+mapnumber+".json");
  }
}
class Platform{
  float w,h,x,y;
  int id;
  String typeof;
  float halfWidth, halfHeight;

  Platform(float _x, float _y, float _w, float _h, String _typeof, int _id){
    w = _w;
    h = _h;
    x = _x;
    y = _y;
    id = _id;
    typeof = _typeof;

    halfWidth = w/2;
    halfHeight = h/2;
  }

   public void display(){
    
    
    //Used to for goal
    fill(255,255,0);
    if(id==-1)
    rect(x,y,w,h);
    if(id!=0 && id!=-1)
    image(tiles[id-1],x,y,w,h);
    
  }
}

class tileEditor{
  float mapX,mapY;
  int posX, posY;
  int pickedtile=0;
  PImage small;
  boolean picked;
  
  
   public void draw(){
    fill(255, 255, 255);
    rect(camera.x,camera.y+400,128,96);
    image(tileset,camera.x,camera.y+400);
  }
   public void cutImage(){
    if(mousePressed&&mouseX<128&&(496>mouseY&&mouseY>400)){
      posX= PApplet.parseInt(mouseX/16);
      posY= PApplet.parseInt((mouseY-400)/16);
      
       small = tileset.get(posX*16,posY*16,16,16);
       picked = true;
     
       pickedtile=posX+posY*8+1;
     
       text(" "+ pickedtile,mouseX+camera.x,mouseY+camera.y);
    }
  }
   public void putTile(){
    if(picked){
      image(small, mouseX+camera.x,mouseY+camera.y,64,64);
      text(" "+ pickedtile,mouseX+camera.x,mouseY+camera.y);
    }
    //Logic for editing map ingame
    if(!(mouseX<128&&496>mouseY&&mouseY>400)&&mousePressed&&picked&&(PApplet.parseInt((mouseY+camera.y)+2580)<2880)){
      if(pickedtile==48){
        IDs[(PApplet.parseInt(((mouseY+camera.y)+2580)/16)*60)+PApplet.parseInt((mouseX+camera.x)/16)] = 0;
      }else{
        IDs[(PApplet.parseInt(((mouseY+camera.y)+2580)/16)*60)+PApplet.parseInt((mouseX+camera.x)/16)] = pickedtile;
      }
      MapJSON.JsonPrint();
      MapJSON.JsonRead(IDs);
      for(int y = 0; y < 180;y++){
        for(int x = 0; x < 60;x++){
          platforms[y*60+x] = new Platform (x*16,y*16-2580,16,16,"safe",IDs[y*60+x]);
       }
      }
     
     }
  }
 }
class WinPlatform{
  
  Platform GOAL;
  
   public void nextStage(){
    MapJSON.JsonRead(IDs);
    //Telepors player to start
    h.x=400;
    h.y=150;
    //Loads new map
    for(int y = 0; y < 180;y++){
      for(int x = 0; x < 60;x++){
        platforms[y*60+x] = new Platform (x*16,y*16-2580,16,16,"safe",IDs[y*60+x]);
      }
    }
  }
}


  public void settings() { size(800, 960); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Jumper" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
